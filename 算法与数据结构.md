# 算法



## 双指针法

算法流程：

* 初始化： 双指针 i , j 分别指向数组 nums 的左右两端 （俗称对撞双指针）。

* 循环搜索： 当双指针相遇时跳出；

  * 计算和 s = nums[i] + nums[j]s；

  * 若 s > targets ，则指针 j 向左移动，即执行 j = j - 1 ；

  * 若 s < targets ，则指针 i 向右移动，即执行 i = i + 1 ；

  * 若 s = target ，立即返回数组 [nums[i], nums[j]]；

* 返回空数组，代表无和为 target 的数字组合。

  

## 二分查找





## 快速幂

它可以以![[公式]](https://www.zhihu.com/equation?tex=O%28%5Clog+n%29)的时间复杂度计算乘方

7的10次方，我们把10写成**二进制**的形式，也就是 ![[公式]](https://www.zhihu.com/equation?tex=%281010%29_2) 。

现在我们要计算 ![[公式]](https://www.zhihu.com/equation?tex=7%5E%7B%281010%29_2%7D) ，可以怎么做？我们很自然地想到可以把它拆分为 ![[公式]](https://www.zhihu.com/equation?tex=7%5E%7B%281000%29_2%7D+%5Ccdot+7%5E%7B%2810%29_2%7D+) . 实际上，对于任意的整数，我们都可以把它拆成若干个 ![[公式]](https://www.zhihu.com/equation?tex=7%5E%7B%28100...%29_2%7D) 的形式相乘。而这些![[公式]](https://www.zhihu.com/equation?tex=7%5E%7B%28100...%29_2%7D)，恰好就是 ![[公式]](https://www.zhihu.com/equation?tex=7%5E1) 、![[公式]](https://www.zhihu.com/equation?tex=7%5E2)、![[公式]](https://www.zhihu.com/equation?tex=7%5E4)……我们只需**不断把底数平方**就可以算出它们。

```cpp
//非递归快速幂
int qpow(int a, int n){
    int ans = 1;
    while(n){
        if(n&1)        //如果n的当前末位为1
            ans *= a;  //ans乘上当前的a
        a *= a;        //a自乘
        n >>= 1;       //n往右移一位
    }
    return ans;
}
```

最初ans为1，然后我们一位一位算：

1010的最后一位是0，所以a^1 这一位不要。然后1010右移一位变为101，a变为a^2。

101的最后一位是1，所以a^2这一位是需要的，乘入ans。101变为100，同时100的最后一位是0，右移一位变为10，a再自乘。

10的最后一位是0，右移，自乘。

然后1的最后一位是1，ans再乘上a(此时a的值为a^8)。循环结束，返回结果。

![img](https://pic3.zhimg.com/80/v2-e99e321dcff33699093cde2876424dbe_720w.jpg)

这里的位运算符，**>>**是右移，表示把二进制数**往右移一位**，相当于/2；&是按位与，&1可以理解为**取出二进制数的最后一位**，相当于%2==1。





## DFS深度优先









## BFS广度优先搜索算法

广度优先搜索算法（Breadth-First Search，BFS）是一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。BFS并不使用经验法则算法。

广度优先搜索让你能够找出两样东西之间的**最短距离**，不过最短距离的含义有很多！使用广度优先搜索可以：

* 编写国际跳棋AI，计算最少走多少步就可获胜；
* 编写拼写检查器，计算最少编辑多少个地方就可将错拼的单词改成正确的单词，如将READED改为READER需要编辑一个地方；
* 根据你的人际关系网络找到关系最近的医生。





# 数据结构



## 双端队列 deque

* Vector 容器是单向开口的连续内存空间，deque 则是一种双向开口的连续线性空间。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，vector 容器也可以在头尾两端插入元素，但是在其头部操作效率奇差，无法被接受。
* deque 容器和 vector 容器最大的差异，一在于 deque 允许使用常数项时间对头端进行元素的插入和删除操作。二在于 deque 没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像 vector 那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在 deque 身上是不会发生的。也因此，deque 没有必须要提供所谓的空间保留(reserve)功能。
* 虽然 deque 容器也提供了 Random Access Iterator,但是它的迭代器并不是普通的指针，其复杂度和 vector 不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用 vector，而不是 deque。对 deque 进行的排序操作，为了最高效率，可将 deque 先完整的复制到一个 vector 中，对 vector 容器进行排序，再复制回 deque。









